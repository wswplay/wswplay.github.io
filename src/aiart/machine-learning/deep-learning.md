---
title: 深度学习
---

# 深度学习

## 微积分(导数-梯度)

#### 为什么叫「微积分」

从微积分基本定理可以看出，积分和微分实际上是逆过程：
:::tip

- 微分是通过局部的变化率来描述函数的行为。
- 积分是通过累积这些局部的变化（面积）来得到总体的行为。
  :::

将微分和积分联系起来的基本定理显示了它们是相辅相成的，解决问题时经常需要同时使用。

比如，解决一个运动问题，可能需要`先用微分来描述速度，然后用积分来计算距离`。因此，在数学中，这两个操作结合起来被称为「微积分」。

**微分**和**积分**是微积分的两个分支，**微分**可以应用于深度学习中的**优化**问题。

**导数**可以被解释为函数相对于其变量的**瞬时变化率(速度)**，它也是函数曲线的**切线的斜率**。

**梯度**是一个**向量**，其分量是多变量函数相对于其所有变量的**偏导数**。

**链式法则**，可以用来微分复合函数。

## 术语

**训练集**：在机器学习的术语中，该数据集称为训练数据集(`training data set`) 或训练集(`training set`)。

**样本**：每行数据(比如一次房屋交易相对应的数据)称为样本(`sample`)， 也可以称为数据点(`data point`)或数据样本(`data instance`)。

**目标/标签**：我们把试图预测的目标(比如预测房屋价格)称为标签(`label`)或目标(`target`)。

**特征**：预测所依据的自变量(面积和房龄)称为特征(`feature`)或协变量(`covariate`)。

## 形态

- **欠拟合**：这些曲线之间的差距很小，验证损失从未增加，因此网络拟合不足的可能性比拟合过度的可能性更大。如果真是这样的话，那就值得试验更多的容量。

- **过拟合**：现在，验证损失很早就开始增加，而训练损失继续减少。这表明网络已经开始过度填充。在这一点上，我们需要尝试一些措施来防止它，要么减少单位数量，要么通过提前停止等方法。

- **提前停止**：一旦开始过拟合，早期停止回调确实停止了训练。此外，通过包括 `restore_best_weights`，我们仍然可以将模型保持在验证损失最低的位置。

## 仿射变换

**仿射变换**（`affine transformation`），特点是通过`加权`和对特征进行`线性变换`（linear transformation）， 并通过`偏置项`来进行平移（`translation`）。

## 从线性回归到深度网络

![An image](./img/singleneuron.svg)

线性回归是一个**单层神经网络**，层数为 1。我们可以将线性回归模型视为仅由单个人工神经元组成的神经网络，或称为单层神经网络。

对于线性回归，每个输入都与每个输出（在本例中只有一个输出）相连，称为全连接层（fully-connected layer）或称为稠密层（dense layer）。

## 多层感知机

线性意味着单调假设，可能会出错。我们可以通过在网络中加入一个或多个**隐藏层**来克服线性模型的限制， 使其能处理更普遍的函数关系类型。对于深度神经网络，我们使用观测数据来联合学习隐藏层表示和应用于该表示的线性预测器。

![An image](./img/mlp.svg)

我们可以通过在网络中加入一个或多个隐藏层来克服线性模型的限制， 使其能处理更普遍的函数关系类型。 要做到这一点，最简单的方法是将许多全连接层堆叠在一起。 每一层都输出到上面的层，直到生成最后的输出。 我们可以把前层看作表示，把最后一层看作线性预测器。 这种架构通常称为多层感知机（`multilayer perceptron`），通常缩写为`MLP`。

为了发挥多层架构的潜力，我们还需要一个额外的关键要素：在仿射变换之后对每个隐藏单元应用**非线性**的**激活函数（activation function）**。激活函数的输出被称为活性值（activations）。一般来说，有了激活函数，就不可能再将我们的多层感知机退化成线性模型。

### 激活函数

激活函数（`activation function`）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。

#### ReLU

最受欢迎的激活函数是修正线性单元（`Rectified linear unit`，**ReLU**），因为它实现简单，同时在各种预测任务中表现良好。ReLU 提供了一种非常简单的非线性变换。

给定元素`x`，`ReLU`函数被定义为该元素与 0 的最大值：`ReLU(x) = max(x, 0)`。

```python
import torch
from d2l import torch as d2l

x = torch.arange(-8.0, 8.0, 0.5, requires_grad=True)
y = torch.relu(x)
d2l.plot(x.detach(), y.detach(), 'x', 'relu(x)', figsize=(5, 2.5))
```

![An image](./img/relu.svg)

`当输入为负时，ReLU 函数的导数为 0`，`而当输入为正时，ReLU 函数的导数为 1`。 注意，当输入值精确等于 0 时，ReLU 函数不可导。 在此时，我们默认使用左侧的导数，即当输入为 0 时导数为 0。 我们可以忽略这种情况，因为输入可能永远都不会是 0。 这里引用一句古老的谚语，“**如果微妙的边界条件很重要，我们很可能是在研究数学而非工程**”， 这个观点正好适用于这里。 下面我们绘制 ReLU 函数的导数。

```python
y.backward(torch.ones_like(x), retain_graph=True)
d2l.plot(x.detach(), x.grad, 'x', 'grad of relu', figsize=(5, 2.5))
```

![An image](./img/relu_grad.svg)

使用 ReLU 的原因是，它求导表现得特别好：**要么让参数消失，要么让参数通过**。 这使得优化表现得更好，并且 ReLU 减轻了困扰以往神经网络的**梯度消失**问题。

在 PyTorch 的反向传播过程中，使用 `torch.ones_like(x)` 是为了方便地计算标量损失的梯度。在反向传播时，初始的梯度是用来告诉 PyTorch 如何从标量开始传播梯度。

**为什么使用 `torch.ones_like(x)`？**

1. **默认行为**:

   - 如果 `y` 是一个标量（单个值），调用 `y.backward()` 时，默认会传递一个值为 1 的梯度，意思是对 `y` 本身的梯度为 1，这符合链式法则。
   - 如果 `y` 是非标量（例如一个向量或矩阵），则需要你指定对每个元素的梯度权重，这就是为什么传入 `torch.ones_like(x)`，它为每个元素都传入 1。

2. **梯度传递**:

   - 使用 1 表示你想要计算 `y` 对 `x` 的真实梯度。因为链式法则中的乘法会逐步传播梯度，所以对标量输出的梯度为 1 是最直观的，表示不改变梯度大小，只传播真实的梯度。

3. **最常见的场景**:
   - 这种用法最常见的场景是当你在计算一个损失函数时，损失通常是标量，例如交叉熵损失或均方误差损失。在这种情况下，损失相对于模型参数的梯度自然就是相对于标量的梯度，即 1。

#### sigmoid

对于一个定义域在 `R` 中的输入， `sigmoid` 函数将输入变换为区间(0, 1)上的输出。 `因此，sigmoid` 通常称为**挤压函数（squashing function）**: 它将范围`（-inf, inf）`中的任意输入压缩到区间`（0, 1）`中的某个值。

在最早的神经网络中，科学家们感兴趣的是对“激发”或“不激发”的生物神经元进行建模。 因此，这一领域的先驱可以一直追溯到人工神经元的发明者麦卡洛克和皮茨，他们专注于阈值单元。 阈值单元在其输入低于某个阈值时取值 0，当输入超过阈值时取值 1。

当我们想要将输出视作二元分类问题的概率时， sigmoid 仍然被广泛用作输出单元上的激活函数，后面关于循环神经网络的章节中，我们将描述利用 sigmoid 单元来控制时序信息流的架构。

当输入接近 0 时，sigmoid 函数接近线性变换。（`sigmoid` 可以视为 `softmax` 的特例）

```python
y = torch.sigmoid(x)
d2l.plot(x.detach(), y.detach(), 'x', 'sigmoid(x)', figsize=(5, 2.5))
```

![An image](./img/sigmoid.svg)

#### tanh

与 `sigmoid` 函数类似，`tanh(双曲正切)`函数也能将其输入压缩转换到区间`(-1, 1)`上。当输入在 0 附近时，tanh 函数接近线性变换。 函数的形状类似于 sigmoid 函数， 不同的是 tanh 函数关于坐标系原点中心对称。

```python
y = torch.tanh(x)
d2l.plot(x.detach(), y.detach(), 'x', 'tanh(x)', figsize=(5, 2.5))
```

![An image](./img/tanh.svg)

### 向前传播

前向传播（`forward propagation 或 forward pass`） 指的是：按**顺序**（从输入层到输出层）**计算和存储**神经网络中每层的**结果**。

### 反向传播

反向传播（`backward propagation 或 backpropagation`）指的是计算神经网络参数**梯度**的方法。 简言之，该方法根据**微积分**中的链式规则，按**相反的顺序**从输出层到输入层遍历网络。 该算法存储了计算某些参数梯度时所需的**任何中间变量（偏导数）**。

### 训练神经网络

因此，在训练神经网络时，在初始化模型参数后， 我们**交替使用**前向传播和反向传播，利用反向传播给出的梯度来更新模型参数。 注意，反向传播重复利用前向传播中存储的中间值，以避免重复计算。 带来的影响之一是我们需要保留中间值，直到反向传播完成。 这也是训练比单纯的预测需要更多的内存（显存）的原因之一。 此外，这些中间值的大小与网络层的数量和批量的大小大致成正比。 因此，使用更大的批量来训练更深层次的网络更容易导致内存不足（`out of memory`）错误。

### 小结

- 前向传播在神经网络定义的计算图中按顺序计算和存储中间变量，顺序是从输入层到输出层。
- 反向传播按相反顺序（从输出层到输入层），计算和存储中间变量和参数的梯度。
- 在训练深度学习模型时，前向传播和反向传播是相互依赖的。
- 训练比预测需要更多的内存。
